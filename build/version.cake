public class BuildVersion
{
    public string Version { get; private set; }

    // Version to patch into project.json (--package-version is missing on dotnet-pack)
    public string PkgVersion { get; private set; }

    // Semantic Version
    public string SemVersion { get; private set; }

    public string InformationalVersion { get; private set; }

    // CommonAssemblyInfo variables
    // TODO: the [Assembly*Version] attributes are generated by dotnet-build. Can this be changed?
    // public string AssemblyFileVersion { get; private set; }
    // public string AssemblyInformationalVersion { get; private set; }

    // --version-suffix on dotnet-pack
    public string DotNetVersionSuffix { get; private set; }

    public string CakeVersion { get; private set; }

    public static BuildVersion Calculate(ICakeContext context, BuildParameters parameters)
    {
        if (context == null)
        {
            throw new ArgumentNullException("context");
        }

        string version = null;
        string pkgVersion = null;
        string semVersion = null;
        string infoVersion = null;

        // Only calculate version on windows....why....does gitVersion not support .NEt Core yet???
        if (context.IsRunningOnWindows())
        {
            context.Information("Calculating version.");

            // AssemblyVersion will be set to the AssemblySemVer variable
            // AssemblyFileVersion will be set to the MajorMinorPatch variable with a appended .0.
            // AssemblyInformationalVersion will be set to the InformationalVersion variable.
            if (parameters.IsLocalBuild)
            {
                GitVersion assertedVersions = context.GitVersion(new GitVersionSettings
                {
                    UpdateAssemblyInfoFilePath = "./src/CommonAssemblyInfo.cs",
                    UpdateAssemblyInfo = true,
                    ArgumentCustomization = args => args.Append("/ensureassemblyinfo"),
                    OutputType = GitVersionOutput.Json,
                });

                version = assertedVersions.MajorMinorPatch;
                pkgVersion = assertedVersions.LegacySemVerPadded;
                semVersion = assertedVersions.SemVer;
                infoVersion = assertedVersions.InformationalVersion;
            }
            else
            {
                context.GitVersion(new GitVersionSettings{
                    UpdateAssemblyInfoFilePath = "./src/CommonAssemblyInfo.cs",
                    UpdateAssemblyInfo = true,
                    ArgumentCustomization = args => args.Append("/ensureassemblyinfo"),
                    OutputType = GitVersionOutput.BuildServer
                });

                version = context.EnvironmentVariable("GitVersion_MajorMinorPatch");
                pkgVersion = context.EnvironmentVariable("GitVersion_LegacySemVerPadded");
                semVersion = context.EnvironmentVariable("GitVersion_SemVer");
                infoVersion = context.EnvironmentVariable("GitVersion_InformationalVersion");
            }
        }

        // If skipGitVersion setting is implemented this block of code is important
        if (string.IsNullOrEmpty(version) || string.IsNullOrEmpty(semVersion))
        {
            context.Information("Fetching version from first project.json...");

            version = ReadProjectJsonVersion(context);
            pkgVersion = version;
            semVersion = version;
            infoVersion = version;
        }

        var cakeVersion = typeof(ICakeContext).Assembly.GetName().Version.ToString();

        return new BuildVersion
        {
            Version = version,
            PkgVersion = pkgVersion,
            SemVersion = semVersion,
            InformationalVersion = infoVersion,
            DotNetVersionSuffix = pkgVersion.Substring(version.Length).TrimStart('-'),
            CakeVersion = cakeVersion
        };
    }

    public static string ReadProjectJsonVersion(ICakeContext context)
    {
        var projects = context.GetFiles("./src/**/project.json");
        foreach (var project in projects)
        {
            var content = System.IO.File.ReadAllText(project.FullPath, Encoding.UTF8);
            var node = Newtonsoft.Json.Linq.JObject.Parse(content);
            if (node["version"] != null)
            {
                var version = node["version"].ToString();
                return version.Replace("-*", "");
            }
        }
        throw new CakeException("Could not parse version.");
    }

    public static bool PatchProjectJson(FilePath project, string version)
    {
        // var content = System.IO.File.ReadAllText(project.FullPath, Encoding.UTF8);
        // var node = Newtonsoft.Json.Linq.JObject.Parse(content);
        // if (node["version"] != null)
        // {
        //     node["version"].Replace(version);
        //     System.IO.File.WriteAllText(project.FullPath, node.ToString(), Encoding.UTF8);
        //     return true;
        // };
        // return false;

        bool versionFound = false;
        Newtonsoft.Json.Linq.JObject node;

        using (var file = new System.IO.FileStream(project.FullPath, FileMode.Open))
        using (var stream = new System.IO.StreamReader(file))
        using (var json = new Newtonsoft.Json.JsonTextReader(stream))
        {
            node = Newtonsoft.Json.Linq.JObject.Load(json);
        }

        var versionAttr = node.Property("version");
        if (versionAttr == null)
        {
            node.Add("version", new Newtonsoft.Json.Linq.JValue(version));
            versionFound = false;
        }
        else
        {
            versionAttr.Value = version;
            versionFound = true;
        }

        System.IO.File.WriteAllText(project.FullPath, node.ToString(), Encoding.UTF8);

        return versionFound;
    }
}
